

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyQBTNs.src package &mdash; pyQBTNs 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="pyQBTNs package" href="pyQBTNs.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pyQBTNs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="QBTNs.html">pyQBTNs.QBTNs API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">pyQBTNs</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="pyQBTNs.html">pyQBTNs package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="pyQBTNs.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">pyQBTNs.src package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pyQBTNs.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="pyQBTNs.html#pyqbtns-pyqbtns-module">pyQBTNs.pyQBTNs module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pyQBTNs.html#module-pyQBTNs.version">pyQBTNs.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pyQBTNs.html#module-pyQBTNs">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyQBTNs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">pyQBTNs</a> &raquo;</li>
        
          <li><a href="pyQBTNs.html">pyQBTNs package</a> &raquo;</li>
        
      <li>pyQBTNs.src package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/pyQBTNs.src.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pyqbtns-src-package">
<h1>pyQBTNs.src package<a class="headerlink" href="#pyqbtns-src-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyQBTNs.src.Hierarchical_Tucker">
<span id="pyqbtns-src-hierarchical-tucker-module"></span><h2>pyQBTNs.src.Hierarchical_Tucker module<a class="headerlink" href="#module-pyQBTNs.src.Hierarchical_Tucker" title="Permalink to this headline">¶</a></h2>
<p>Hierarchical Tucker.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyQBTNs.src.Hierarchical_Tucker.Hierarchical_Tucker">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.Hierarchical_Tucker.</span></span><span class="sig-name descname"><span class="pre">Hierarchical_Tucker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Hierarchical_Tucker.html#Hierarchical_Tucker"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Hierarchical_Tucker.Hierarchical_Tucker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyQBTNs.src.Hierarchical_Tucker.Hierarchical_Tucker.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Hierarchical_Tucker.html#Hierarchical_Tucker.train"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Hierarchical_Tucker.Hierarchical_Tucker.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor the input tensor using the Tucker_Recursive algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> (<em>numpy array</em>) – Tensor to be factored.</p></li>
<li><p><strong>dimensions</strong> (<em>list</em>) – tensor dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – factorization ranks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>HT</strong> – dictionary of the tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.Matrix_Factorization">
<span id="pyqbtns-src-matrix-factorization-module"></span><h2>pyQBTNs.src.Matrix_Factorization module<a class="headerlink" href="#module-pyQBTNs.src.Matrix_Factorization" title="Permalink to this headline">¶</a></h2>
<p>Boolean Matrix Factorization.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyQBTNs.src.Matrix_Factorization.Matrix_Factorization">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.Matrix_Factorization.</span></span><span class="sig-name descname"><span class="pre">Matrix_Factorization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NNSVD_INITIAL_STATE_FLAG</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum_converged_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_random_initial_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_initial_state_lower_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_initial_state_upper_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel_bool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Matrix_Factorization.html#Matrix_Factorization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Matrix_Factorization.Matrix_Factorization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Matrix Factorization</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyQBTNs.src.Matrix_Factorization.Matrix_Factorization.factor_matrix">
<span class="sig-name descname"><span class="pre">factor_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RANK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Matrix_Factorization.html#Matrix_Factorization.factor_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Matrix_Factorization.Matrix_Factorization.factor_matrix" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>2-dimensional boolean numpy array</em>) – Boolean matrix to be factored.</p></li>
<li><p><strong>RANK</strong> (<em>integer</em>) – factorization rank.</p></li>
<li><p><strong>A</strong> (<em>2-dimensional boolean numpy array</em>) – Initial state A.</p></li>
<li><p><strong>B</strong> (<em>2-dimensional boolean numpy array</em>) – Initial state B.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>2-dimensional boolean numpy array</em>) – Best found factor (A) for X=AB.</p></li>
<li><p><strong>B</strong> (<em>2-dimensional boolean numpy array</em>) – Best foudn factor (B) for X=AB.</p></li>
<li><p><em>bool</em> – True if exact factorization was found. False otherwise</p></li>
<li><p><strong>error_tracking</strong> (<em>List</em>) – List of hamming distances for each pair of factor matrices (A, B) found.</p></li>
<li><p><strong>error_tracking_data</strong> (<em>List</em>) – Same as error_tracking, but also includes the pairs of matrices A and B.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyQBTNs.src.Matrix_Factorization.Matrix_Factorization.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RANK</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Matrix_Factorization.html#Matrix_Factorization.train"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Matrix_Factorization.Matrix_Factorization.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor the input matrix into A and B given X in the problem X=AB.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> (<em>numpy array</em>) – Tensor to be factored.</p></li>
<li><p><strong>RANK</strong> (<em>integer</em>) – factorization rank.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>numpy array</em>) – First matrix factor.</p></li>
<li><p><strong>B</strong> (<em>numpy array</em>) – Second matrix factor.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.Tensor_Train_Iterative">
<span id="pyqbtns-src-tensor-train-iterative-module"></span><h2>pyQBTNs.src.Tensor_Train_Iterative module<a class="headerlink" href="#module-pyQBTNs.src.Tensor_Train_Iterative" title="Permalink to this headline">¶</a></h2>
<p>Tensor Train Iterative.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyQBTNs.src.Tensor_Train_Iterative.Tensor_Train_Iterative">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.Tensor_Train_Iterative.</span></span><span class="sig-name descname"><span class="pre">Tensor_Train_Iterative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Tensor_Train_Iterative.html#Tensor_Train_Iterative"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Tensor_Train_Iterative.Tensor_Train_Iterative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyQBTNs.src.Tensor_Train_Iterative.Tensor_Train_Iterative.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Tensor_Train_Iterative.html#Tensor_Train_Iterative.train"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Tensor_Train_Iterative.Tensor_Train_Iterative.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor the input tensor using the Tensor_Train_Iterative algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> (<em>numpy array</em>) – Tensor to be factored.</p></li>
<li><p><strong>dimensions</strong> (<em>list</em>) – tensor dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – factorization ranks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>TTlist</strong> – List of factors.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.Tensor_Train_Recursive">
<span id="pyqbtns-src-tensor-train-recursive-module"></span><h2>pyQBTNs.src.Tensor_Train_Recursive module<a class="headerlink" href="#module-pyQBTNs.src.Tensor_Train_Recursive" title="Permalink to this headline">¶</a></h2>
<p>Tensor Train Recursive.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyQBTNs.src.Tensor_Train_Recursive.Tensor_Train_Recursive">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.Tensor_Train_Recursive.</span></span><span class="sig-name descname"><span class="pre">Tensor_Train_Recursive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Tensor_Train_Recursive.html#Tensor_Train_Recursive"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Tensor_Train_Recursive.Tensor_Train_Recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyQBTNs.src.Tensor_Train_Recursive.Tensor_Train_Recursive.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Tensor_Train_Recursive.html#Tensor_Train_Recursive.train"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Tensor_Train_Recursive.Tensor_Train_Recursive.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor the input tensor using the Tensor_Train_Recursive algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> (<em>numpy array</em>) – Tensor to be factored.</p></li>
<li><p><strong>dimensions</strong> (<em>list</em>) – tensor dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – factorization ranks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>TTlist</strong> – List of factors.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.Tucker_Iterative">
<span id="pyqbtns-src-tucker-iterative-module"></span><h2>pyQBTNs.src.Tucker_Iterative module<a class="headerlink" href="#module-pyQBTNs.src.Tucker_Iterative" title="Permalink to this headline">¶</a></h2>
<p>Tuckeer Iterative.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyQBTNs.src.Tucker_Iterative.Tucker_Iterative">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.Tucker_Iterative.</span></span><span class="sig-name descname"><span class="pre">Tucker_Iterative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Tucker_Iterative.html#Tucker_Iterative"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Tucker_Iterative.Tucker_Iterative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyQBTNs.src.Tucker_Iterative.Tucker_Iterative.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Tucker_Iterative.html#Tucker_Iterative.train"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Tucker_Iterative.Tucker_Iterative.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor the input tensor using the Tucker_Iterative algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> (<em>numpy array</em>) – Tensor to be factored.</p></li>
<li><p><strong>dimensions</strong> (<em>list</em>) – tensor dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – factorization ranks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>T</strong> (<em>numpy array</em>) – tensor core.</p></li>
<li><p><strong>matrixList</strong> (<em>list</em>) – list of matrices.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.Tucker_Recursive">
<span id="pyqbtns-src-tucker-recursive-module"></span><h2>pyQBTNs.src.Tucker_Recursive module<a class="headerlink" href="#module-pyQBTNs.src.Tucker_Recursive" title="Permalink to this headline">¶</a></h2>
<p>Tucker Recursive.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyQBTNs.src.Tucker_Recursive.Tucker_Recursive">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.Tucker_Recursive.</span></span><span class="sig-name descname"><span class="pre">Tucker_Recursive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Tucker_Recursive.html#Tucker_Recursive"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Tucker_Recursive.Tucker_Recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyQBTNs.src.Tucker_Recursive.Tucker_Recursive.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/Tucker_Recursive.html#Tucker_Recursive.train"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.Tucker_Recursive.Tucker_Recursive.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor the input tensor using the Tucker_Recursive algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> (<em>numpy array</em>) – Tensor to be factored.</p></li>
<li><p><strong>dimensions</strong> (<em>list</em>) – tensor dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – factorization ranks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>core</strong> (<em>numpy array</em>) – tensor core.</p></li>
<li><p><strong>factors</strong> (<em>list</em>) – list of matrix factors.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.classical_solve">
<span id="pyqbtns-src-classical-solve-module"></span><h2>pyQBTNs.src.classical_solve module<a class="headerlink" href="#module-pyQBTNs.src.classical_solve" title="Permalink to this headline">¶</a></h2>
<p>Classical (local) solver methods.</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.classical_solve.batch_classical_single_QUBO">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.classical_solve.</span></span><span class="sig-name descname"><span class="pre">batch_classical_single_QUBO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/classical_solve.html#batch_classical_single_QUBO"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.classical_solve.batch_classical_single_QUBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the individual column factorization problems using classical algorithms such as simulated anealing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>2-d numpy array</em>) – matrix to be factored.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – column index.</p></li>
<li><p><strong>A</strong> (<em>2-d numpy array</em>) – Initial state.</p></li>
<li><p><strong>B</strong> (<em>2-d numpy array</em>) – Initial state. Not used. Here for the logical consistency.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>optional</em>) – random state. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – list of (b) columns which solve the matrix factorization problem of X=AB.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.classical_solve.call_simulated_annealing">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.classical_solve.</span></span><span class="sig-name descname"><span class="pre">call_simulated_annealing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">QUBO</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/classical_solve.html#call_simulated_annealing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.classical_solve.call_simulated_annealing" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the simulated annealing method from the DWave API</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QUBO</strong> (<em>dictionary</em>) – quadratic unconstrained binary optimization problem.</p></li>
<li><p><strong>random_state</strong> (<em>integer</em><em>, </em><em>optional</em>) – random seed. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out_vector</strong> (<em>list</em>) – list of dictionaries, where each dictionary is a good solution to the QUBO.</p></li>
<li><p><strong>CPU_TIME</strong> (<em>float</em>) – CPU process time.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.classical_solve.call_steepest_descent">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.classical_solve.</span></span><span class="sig-name descname"><span class="pre">call_steepest_descent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">QUBO</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/classical_solve.html#call_steepest_descent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.classical_solve.call_steepest_descent" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QUBO</strong> (<em>dictionary</em>) – quadratic unconstrained binary optimization problem.</p></li>
<li><p><strong>random_state</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – random seed. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out_vector</strong> (<em>list</em>) – list of dictionaries, where each dictionary is a good solution to the QUBO.</p></li>
<li><p><strong>CPU_TIME</strong> (<em>float</em>) – CPU process time in seconds.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.classical_solve.call_tabu_sampler">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.classical_solve.</span></span><span class="sig-name descname"><span class="pre">call_tabu_sampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">QUBO</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/classical_solve.html#call_tabu_sampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.classical_solve.call_tabu_sampler" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QUBO</strong> (<em>dictionary</em>) – quadratic unconstrained binary optimization problem.</p></li>
<li><p><strong>random_state</strong> (<em>integer</em><em>, </em><em>optional</em>) – random seed. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out_vector</strong> (<em>list</em>) – list of dictionaries, where each dictionary is a good solution to the QUBO.</p></li>
<li><p><strong>CPU_TIME</strong> (<em>float</em>) – CPU process time.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.classical_solve.classical_single_QUBO">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.classical_solve.</span></span><span class="sig-name descname"><span class="pre">classical_single_QUBO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">As</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_QUBOS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/classical_solve.html#classical_single_QUBO"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.classical_solve.classical_single_QUBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses classical QUBO solvers to solve individual QUBOs at a time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>As</strong> (<em>dictionary</em>) – In this case the dictionary has a single entry because we are only solving one QUBO at a time.
The single value is a numpy array A from x=Ab (we are solving for the column vector b).
The key is tracking which column-factorization sub-problem this A is from.</p></li>
<li><p><strong>xs</strong> (<em>dictionary</em>) – In this case the dictionary has a single entry because we are only solving one QUBO at a time.
The only value is a numpy array (vector) of x in x=Ab. The only key is tracking which column-
factorization sub-problem this x is from.</p></li>
<li><p><strong>all_QUBOS</strong> (<em>dictionary</em>) – In this case the dictionary has a single entry because we are only solving one QUBO at a time.
The QUBO is the only value, and the key is the QUBO integer label from the embedding.</p></li>
<li><p><strong>solver_method</strong> (<em>string</em>) – QUBO solver method. Allowed values are “classical-simulated-annealing”,
“classical-steepest-descent”,
“classsical-tabu-sampler”,
“d-wave”</p></li>
<li><p><strong>random_state</strong> (<em>integer</em><em>, </em><em>optional</em>) – random state seed. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>bcol_solution_dict</strong> (<em>dict</em>) – Keys are the column-factorization sub problem index, and values are the solved b-column solutions.</p></li>
<li><p><strong>TOTAL_CPU_TIME</strong> (<em>float</em>) – total CPU process time.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.generate_fixed_embeddings">
<span id="pyqbtns-src-generate-fixed-embeddings-module"></span><h2>pyQBTNs.src.generate_fixed_embeddings module<a class="headerlink" href="#module-pyQBTNs.src.generate_fixed_embeddings" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.generate_fixed_embeddings.iterative_embedding">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.generate_fixed_embeddings.</span></span><span class="sig-name descname"><span class="pre">iterative_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CONNECTIVITY_GRAPH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_clique_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/generate_fixed_embeddings.html#iterative_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.generate_fixed_embeddings.iterative_embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic method computes many disjoint embeddings for cliques of size
target_clique_size onto CONNECTIVITY_GRAPH.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>CONNECTIVITY_GRAPH</strong> (<em>networkx.Graph</em><em>(</em><em>)</em>) – Quantum annealer hardware connectivity graph.</p></li>
<li><p><strong>target_clique_size</strong> (<em>integer</em>) – small clique we want to embed as many times as possible onto the hardware.</p></li>
<li><p><strong>random_state</strong> (<em>integer</em><em>, </em><em>optional</em>) – random seed. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>all_subgraphs</strong> – list of  the edges  of the subgraphs, each subgraph can embed a clique
of size target_clique_size.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.generate_fixed_embeddings.iterative_search">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.generate_fixed_embeddings.</span></span><span class="sig-name descname"><span class="pre">iterative_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CONNECTIVITY_GRAPH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_clique_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/generate_fixed_embeddings.html#iterative_search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.generate_fixed_embeddings.iterative_search" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>CONNECTIVITY_GRAPH</strong> (<em>networkx.Graph</em><em>(</em><em>)</em>) – quantum annealer hardware connectivity graph.</p></li>
<li><p><strong>starting_node</strong> (<em>integer</em>) – integer that repressents a node in the hardware graph.</p></li>
<li><p><strong>target_clique_size</strong> (<em>integer</em>) – small clique we want to embed multiple times.</p></li>
<li><p><strong>random_state</strong> (<em>integer</em><em>, </em><em>optional</em>) – random seed. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>-1 if search failed, otherwise a suitable subgraph for the small clique size.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>-1 or netowkrx.Graph()</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.quantum_solve">
<span id="pyqbtns-src-quantum-solve-module"></span><h2>pyQBTNs.src.quantum_solve module<a class="headerlink" href="#module-pyQBTNs.src.quantum_solve" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.quantum_solve.batch_parallel_quantum_annealing">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.quantum_solve.</span></span><span class="sig-name descname"><span class="pre">batch_parallel_quantum_annealing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/quantum_solve.html#batch_parallel_quantum_annealing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.quantum_solve.batch_parallel_quantum_annealing" title="Permalink to this definition">¶</a></dt>
<dd><p>Submits multiple column factorizaiton problems at once to D-Wave
(Up to however many small cliques were found in the embedding stage).
This method is called parallel quantum annealing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>2-d numpy array</em>) – matrix to be factored.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – column index.</p></li>
<li><p><strong>A</strong> (<em>2-d numpy array</em>) – Initial state.</p></li>
<li><p><strong>B</strong> (<em>2-d numpy array</em>) – Initial state. Not used. Here for the logical consistency.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>optional</em>) – random state. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – list of solved columns.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.quantum_solve.batch_quantum_annealing">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.quantum_solve.</span></span><span class="sig-name descname"><span class="pre">batch_quantum_annealing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/quantum_solve.html#batch_quantum_annealing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.quantum_solve.batch_quantum_annealing" title="Permalink to this definition">¶</a></dt>
<dd><p>Submits one column factorization problem to D-Wave at a time;
i.e. each column factorization problem is solved sequentially.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>2-d numpy array</em>) – matrix to be factored.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – column index.</p></li>
<li><p><strong>A</strong> (<em>2-d numpy array</em>) – Initial state.</p></li>
<li><p><strong>B</strong> (<em>2-d numpy array</em>) – Initial state. Not used. Here for the logical consistency.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>optional</em>) – random state. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – list of (b) columns.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.quantum_solve.parallel_quantum_annealing">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.quantum_solve.</span></span><span class="sig-name descname"><span class="pre">parallel_quantum_annealing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">all_embs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">As</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_QUBOS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DWave_solver</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/quantum_solve.html#parallel_quantum_annealing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.quantum_solve.parallel_quantum_annealing" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the DWave solver using the parallel quantum annealing method. Solving the boolean column factorization problem x=Ab, where x and b are columns and A is a matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>all_embs</strong> (<em>dict</em>) – Parallel QA embeddings. Keys are unique embedding identifiers. Values are the small clique embeddings</p></li>
<li><p><strong>As</strong> (<em>dict</em>) – Keys are problem indexes. Value is the initial state boolean array (matrix) A.</p></li>
<li><p><strong>xs</strong> (<em>dict</em>) – Keys are problem indexes. Value is the x-column vector to be factored.</p></li>
<li><p><strong>all_QUBOS</strong> (<em>dict</em>) – Keys are problem indexes. Values are QUBO dictionaries.</p></li>
<li><p><strong>connectivity_graph</strong> (<em>networkx.Graph</em><em>(</em><em>)</em>) – Undirected hardware connectivity graph of the DWave solver.</p></li>
<li><p><strong>DWave_solver</strong> (<em>dwave.cloud.client.solver</em>) – DWave solver object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>resulting_columns</strong> – solved b-columns. Each key is the index for that column (so we can stitch together the results into our B matrix).
Each value is a list of 0 and 1 (boolean) vectors.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.quantum_solve.quantum_annealing">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.quantum_solve.</span></span><span class="sig-name descname"><span class="pre">quantum_annealing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">As</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_QUBOS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DWave_solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_embedding</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/quantum_solve.html#quantum_annealing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.quantum_solve.quantum_annealing" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-Parallel Quantum Annealing
For ranks that are not 3</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>As</strong> (<em>dict</em>) – Keys are problem indexes. Value is the initial state boolean array (matrix) A.</p></li>
<li><p><strong>xs</strong> (<em>dict</em>) – Keys are problem indexes. Value is the x-column vector to be factored.</p></li>
<li><p><strong>all_QUBOS</strong> (<em>dict</em>) – Keys are problem indexes. Values are QUBO dictionaries.</p></li>
<li><p><strong>connectivity_graph</strong> (<em>networkx.Graph</em><em>(</em><em>)</em>) – Undirected hardware connectivity graph of the DWave solver.</p></li>
<li><p><strong>DWave_solver</strong> (<em>dwave.cloud.client.solver</em>) – DWave solver object.</p></li>
<li><p><strong>complete_embedding</strong> (<em>dict</em>) – Keys are the variable indexes (for the LANL 2000Q this is 0-64). Values are lists of the physical qubits (chain) for that variable index.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bcol_solution_dict</strong> – keys are the problem index. Values are the best found b-column for that particular column factorization problem.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.tensor_utils">
<span id="pyqbtns-src-tensor-utils-module"></span><h2>pyQBTNs.src.tensor_utils module<a class="headerlink" href="#module-pyQBTNs.src.tensor_utils" title="Permalink to this headline">¶</a></h2>
<p>Tensor Utilities.</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.boolArray">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">boolArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#boolArray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.boolArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random boolean array of size l with proportion of True/False according to p</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> (<em>list</em>) – list of sizes.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – proportion of False entries for constructing random boolean numpy arrays.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>t</strong> – numpy array of order length of l.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.construct_HT">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">construct_HT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#construct_HT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.construct_HT" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct HT dictionary</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims</strong> (<em>list</em>) – list of dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – list of ranks.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – proportion of True and False elements for generating random boolean arrays.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>HT</strong> – Reconstructed HT network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.construct_tensor_TT">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">construct_tensor_TT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RANK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#construct_tensor_TT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.construct_tensor_TT" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a tensor train tensor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dimensions</strong> (<em>list</em>) – list of dimensions. The length of this list is the order.</p></li>
<li><p><strong>RANK</strong> (<em>int</em>) – factorization rank.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – proportion of True and False elements for generating random boolean arrays.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>reconstruct_TT(TT_list)</strong> – reconstructed Tensor Train tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.construct_tucker_tensor">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">construct_tucker_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#construct_tucker_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.construct_tucker_tensor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims</strong> (<em>list</em>) – list of dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – list of ranks.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – proportion of True and False elements for generating random boolean arrays.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>optional</em>) – random state. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>core</strong> (<em>numpy array</em>) – DESCRIPTION.</p></li>
<li><p><strong>factors</strong> (<em>list</em>) – List of numpy arrays, which are the constructed factors of the tensor</p></li>
<li><p><strong>tensor</strong> (<em>numpy array</em>) – Tensor in the form of a boolean numpy array</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.reconstruct_HT">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">reconstruct_HT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">HT</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#reconstruct_HT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.reconstruct_HT" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs a tensor given an input of factors generated from running the
Hierarchical Tucker algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>HT</strong> (<em>dict</em>) – factors from Hierarchical Tucker algorithm.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>prod</strong> – tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.reconstruct_TT">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">reconstruct_TT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#reconstruct_TT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.reconstruct_TT" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs a tensor given an input of factors generated from running the Tensor Train algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>factors</strong> (<em>list</em>) – list of matrices.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>prod</strong> – reconstructed tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.reconstruct_tucker">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">reconstruct_tucker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">core</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#reconstruct_tucker"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.reconstruct_tucker" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs a tensor given an input of factors generated from running the Tucker algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>core</strong> (<em>numpy array</em>) – core tensor.</p></li>
<li><p><strong>factors</strong> (<em>list</em>) – list of matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>prod</strong> – tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.split_HT">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">split_HT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#split_HT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.split_HT" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims</strong> (<em>list</em>) – list of dimensions.</p></li>
<li><p><strong>rng</strong> (<em>range</em>) – range of indexes in the dimension list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – product of dimensions in rng.</p></li>
<li><p><em>list</em> – list of a subset (in rng) of dimensionss.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.split_TT">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">split_TT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#split_TT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.split_TT" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>numpy array</em>) – Tensor or possible matrix. Boolean numpy array.</p></li>
<li><p><strong>dims</strong> (<em>list</em>) – list of dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – list of ranks.</p></li>
<li><p><strong>rng</strong> (<em>range</em>) – range of indexes in the dimension list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – product of dimensions in rng.</p></li>
<li><p><em>list</em> – list of a subset (in rng) of dimensionss.</p></li>
<li><p><em>list</em> – list of a subset (in rng) of ranks.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.tensor_utils.split_tucker">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.tensor_utils.</span></span><span class="sig-name descname"><span class="pre">split_tucker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/tensor_utils.html#split_tucker"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.tensor_utils.split_tucker" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims</strong> (<em>list</em>) – list of dimensions.</p></li>
<li><p><strong>ranks</strong> (<em>list</em>) – list of ranks.</p></li>
<li><p><strong>rng</strong> (<em>range</em>) – range of indexes in the dimension list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – product of dimensions in rng.</p></li>
<li><p><em>list</em> – list of a subset (in rng) of dimensionss.</p></li>
<li><p><em>list</em> – list of a subset (in rng) of ranks.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src.utils">
<span id="pyqbtns-src-utils-module"></span><h2>pyQBTNs.src.utils module<a class="headerlink" href="#module-pyQBTNs.src.utils" title="Permalink to this headline">¶</a></h2>
<p>Utility methods.</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.Start_DWave_connection">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">Start_DWave_connection</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#Start_DWave_connection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.Start_DWave_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a connection to a D-Wave quantum annealer using the defualt information in the user’s
D-Wave config file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>connectivity_graph</strong> (<em>networkx.Graph()</em>) – Undirected hardware connectivity map of the quantum annealer.</p></li>
<li><p><strong>DWave_solver</strong> (<em>DWave solver object</em>) – D-Wave solver object. You can pass problems to this object in order to submit them to be
solved on the quantum annealer.</p></li>
<li><p><strong>solver_name</strong> (<em>str</em>) – Name of the quantum annealer.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.column_solve_postprocess">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">column_solve_postprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_cols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xcol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#column_solve_postprocess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.column_solve_postprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Solving x_col = A*b_col for b_col
This method chooses the best b_col out of however many post-processed solutions were returned by the probabilistic sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b_cols</strong> (<em>list</em>) – List of b-column solutions found by the probabilistic sampler.</p></li>
<li><p><strong>xcol</strong> (<em>list</em>) – target x-column we want to get the factorization of.</p></li>
<li><p><strong>A</strong> (<em>2-d Boolean numpy array</em><em> (</em><em>matrix</em><em>)</em>) – The A in x=Ab.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>selection</strong> – b-column in the form of a list.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.combine_QUBO_storage">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">combine_QUBO_storage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">QUBO_storage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solved_QUBOs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_solutions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#combine_QUBO_storage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.combine_QUBO_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges previous QUBO storage with new solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QUBO_storage</strong> (<em>list</em>) – Input QUBO storage list.</p></li>
<li><p><strong>solved_QUBOs</strong> (<em>dict</em>) – The QUBOs that were solved in this latest iteration.</p></li>
<li><p><strong>column_solutions</strong> (<em>dict</em>) – The associated b-column solutions for each of the solved QUBOs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>QUBO_storage</strong> – Updated QUBO storage with more QUBOs and their recorded solutions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.delete_keys_from_dict">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">delete_keys_from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keys_to_remove</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#delete_keys_from_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.delete_keys_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility to remove specific keys from a dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dictionary</strong> (<em>dict</em>) – Input dictionary.</p></li>
<li><p><strong>keys_to_remove</strong> (<em>list</em>) – list of keys to remove from the dictionary. If this list is
non-unique (i.e. has repeats), then there will be an error. Also, if
any element in this list is not a key in the dictionary, there will
be an error as well.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dictionary</strong> – Dictionary with keys removed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.filter_out_stored_QUBOs">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">filter_out_stored_QUBOs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">QUBO_storage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_QUBOS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_xcols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_Amatrices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#filter_out_stored_QUBOs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.filter_out_stored_QUBOs" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes QUBOs which have been solved previously (as tracked by QUBO_storage).
The best solutions that have been stored are then used instead of calling the solver again on the same QUBO.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QUBO_storage</strong> (<em>list</em>) – Stored QUBOs (and their solutions) that have already been solved.</p></li>
<li><p><strong>all_QUBOS</strong> (<em>dict</em>) – QUBOs to be (potentially) factored in this iteration.</p></li>
<li><p><strong>all_xcols</strong> (<em>dict</em>) – The associated x-columns for each of these QUBOs to be solved.</p></li>
<li><p><strong>all_Amatrices</strong> (<em>dict</em>) – The associated A matrices for each of these QUBOs to be solved..</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>storage_solutions</strong> (<em>dict</em>) – Any solved QUBOs that we do not need to solve again.</p></li>
<li><p><strong>all_QUBOS</strong> (<em>dict</em>) – Updated QUBOs to solve.</p></li>
<li><p><strong>all_xcols</strong> (<em>dict</em>) – Updated x-columns dictionary.</p></li>
<li><p><strong>all_Amatrices</strong> (<em>dict</em>) – Updated A-columns dictionary.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.get_T_F_vecs">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">get_T_F_vecs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#get_T_F_vecs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.get_T_F_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Input of a single column vector, returns the variable indices for both
True and False values in the vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>col</strong> (<em>list</em><em> or </em><em>numpy array</em>) – Input column vector.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>T</strong> (<em>list</em>) – Variable indicies for True variable state.</p></li>
<li><p><strong>F</strong> (<em>list</em>) – Variable indicies for True variable state.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.get_bcols_from_samples">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">get_bcols_from_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#get_bcols_from_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.get_bcols_from_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>From the solved vectors, compute the corresponding b-columns</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>list</em>) – post-processed vectors.</p></li>
<li><p><strong>rank</strong> (<em>int</em>) – rank of the column factorization problem.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bcols</strong> – List of solutions found by the probabilistic sampler, in the form of b-columns.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.get_fixed_embedding">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">get_fixed_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">QUBO</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_embedding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#get_fixed_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.get_fixed_embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an input of a QUBO and an embedding, this function maps the variables from
the qubo onto the embedding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QUBO</strong> (<em>dict</em>) – dictionary where the keys are linear or quadratic terms, and the values are real numbers.
Represents a Quadratic Unconstrained Binary Optimization problem.</p></li>
<li><p><strong>complete_embedding</strong> (<em>dict</em>) – all-to-all connectivity embedding for the given QUBO.</p></li>
<li><p><strong>random_state</strong> (<em>integer</em><em>, </em><em>optional</em>) – random seed parameter. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>QUBO_embedding</strong> – remapped embedding for QUBO.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.get_hamming_distance">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">get_hamming_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#get_hamming_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.get_hamming_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the number of dis-similar entries betweeen two numpy arrays.
Here the application is for boolean numpy array, whichis why this metric
is actually hamming distance. Since this comparison is element-wise, the
number of entries in each array needs to be equal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M1</strong> (<em>numpy.array</em>) – Boolean numpy array of arbitrary dimensions. Could be a 1-d, 2-d
array (matrix) or higher order (tensor).</p></li>
<li><p><strong>M2</strong> (<em>numpy.array</em>) – Boolean numpy array of arbitrary dimensions. Could be a 1-d, 2-d
array (matrix) or higher order (tensor).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ham</strong> – Number of unequal elements between the two boolean numpy arrays.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.get_polynomial">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">get_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indicator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#get_polynomial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.get_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Sympy polynomial. This polynmial is a
HUBO (Higher order Unconstrained Binary Optimization) problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>Boolean numpy array</em>) – matrix A in x=Ab.</p></li>
<li><p><strong>V</strong> (<em>list</em>) – Vector passed from the method get_T_F_vecs().</p></li>
<li><p><strong>indicator</strong> (<em>bool</em>) – Boolean variable for storing what coefficient we need in front of the polynomial
A is the other factor of X (or approximate factor of X) we are using.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>all_polynomials</strong> – Higher order polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Sympy polynomial</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.get_qubo">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">get_qubo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bcol_len</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#get_qubo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.get_qubo" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an input of a column factorization problem, i.e. x=Ab where x and b are vectors
and A is amtrix, we  want to find b given x and A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>col</strong> (<em>list</em><em> or </em><em>numpy array</em>) – x-column in the problem x=Ab.</p></li>
<li><p><strong>A</strong> (<em>Boolean numpy array</em>) – matrix A in x=Ab.</p></li>
<li><p><strong>bcol_len</strong> (<em>int</em>) – expected length of the b-column solution vector. Also equal to rank.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>optional</em>) – random state. The default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>QUBO</strong> – QUBO created from the HUBO.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.majority_vote">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">majority_vote</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">problem_embedding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#majority_vote"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.majority_vote" title="Permalink to this definition">¶</a></dt>
<dd><p>Unembeds raw D-Wave samples using the majority vote function.
Unbiased majority vote in that if the chain is split 50-50, then random
choice is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>list</em>) – Raw vectors from the D-Wave solver. The length is equal
to the number of anneals. Each element in vectors is a list of
length equal to the number of qubits on thee D-Wave device. For the
case of a D-Wave 2000Q, the number of qubits  is 2048 (including active and inactive).</p></li>
<li><p><strong>problem_embedding</strong> (<em>dict</em>) – Logical embedding for the problem that D-Wave solved. Keys are
variable names, and values are a list of physical qubits representing
the logical state of the variable (key).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>all_vectors_unembedded</strong> – List of dictionaries. The number of dictionaries is equal to
the length of thee input variable vectors. Each dictionary is
has the same keys as problem_embedding, and the values
are either 0 1 since this function handles QUBOS.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.map_embedding_to_QUBO">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">map_embedding_to_QUBO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">QUBO</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_embedding</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#map_embedding_to_QUBO"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.map_embedding_to_QUBO" title="Permalink to this definition">¶</a></dt>
<dd><p>For each variable in QUBO, this function maps that variable to a set of physical qubits
found in complete_embedding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QUBO</strong> (<em>dict</em>) – keys are linear or quadratic terms, and values are the weights associated
with each of those terms.</p></li>
<li><p><strong>complete_embedding</strong> (<em>dict</em>) – Large all-to-all embedding for the quantum annealing hardware.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – re-mapped embedding .</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.qubo">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">qubo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vars</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#qubo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.qubo" title="Permalink to this definition">¶</a></dt>
<dd><p>expands out the polynomial so we can extract the coefficients for each variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vars</strong> (<em>List</em>) – List of sympy Symbols().</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – QUBO that has been expanded.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Sympy expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.read_complete_embedding">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">read_complete_embedding</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#read_complete_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.read_complete_embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>reads in the all-to-all connectivity embedding that has been strored as a Json.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>complete_embedding</strong> – Keys are logical variables numbereed 0-N. Values are lists of physical qubits that represent
the logical state of the that variable (that variable being the key to that value).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.read_rank3_parallel_QA_embeddings">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">read_rank3_parallel_QA_embeddings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#read_rank3_parallel_QA_embeddings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.read_rank3_parallel_QA_embeddings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>random_state</strong> (<em>int</em><em>, </em><em>optional</em>) – random seed. The default is 42.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rank_3_embeddings</strong> – List of disjoint clique-4 embeddings covering most of the quantum annealing hardware
connectivity graph.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.remove_duplicate_QUBO">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">remove_duplicate_QUBO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">QUBO_storage</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#remove_duplicate_QUBO"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.remove_duplicate_QUBO" title="Permalink to this definition">¶</a></dt>
<dd><p>De-duplicates the QUBO storage list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>QUBO_storage</strong> (<em>list</em>) – List of QUBOs (each QUBO is a dictionary).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>unique</strong> – de-duplicated list.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyQBTNs.src.utils.remove_values_from_list">
<span class="sig-prename descclassname"><span class="pre">pyQBTNs.src.utils.</span></span><span class="sig-name descname"><span class="pre">remove_values_from_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyQBTNs/src/utils.html#remove_values_from_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyQBTNs.src.utils.remove_values_from_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the value targ from the list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_list</strong> (<em>list</em>) – list to remove a value from.</p></li>
<li><p><strong>targ</strong> (<em>usually int</em><em>, </em><em>float</em><em> or </em><em>str</em>) – target value to be removed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List with the target value removed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyQBTNs.src">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyQBTNs.src" title="Permalink to this headline">¶</a></h2>
<p>© 2021. Triad National Security, LLC. All rights reserved.
This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos
National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S.
Department of Energy/National Nuclear Security Administration. All rights in the program are
reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear
Security Administration. The Government is granted for itself and others acting on its behalf a
nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare
derivative works, distribute copies to the public, perform publicly and display publicly, and to permit
others to do so.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="pyQBTNs.html" class="btn btn-neutral float-left" title="pyQBTNs package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, LANL.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>